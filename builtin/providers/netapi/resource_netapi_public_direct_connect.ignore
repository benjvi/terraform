package netapi

import (
	"fmt"
	"net"
	"log"

	"github.com/hashicorp/terraform/helper/schema"
	"github.com/benjvi/go-net-api"
)

func resourceNetAPIPrivateDirectConnect() *schema.Resource {
	return &schema.Resource{
		Create: resourceNetAPIPrivateDirectConnectCreate,
		Read:   resourceNetAPIPrivateDirectConnectRead,
		Delete: resourceNetAPIPrivateDirectConnectDelete,

		Schema: map[string]*schema.Schema{
			"cidr": &schema.Schema{
				Type:     schema.TypeString,
				Required: true,
			},

			"dcg": &schema.Schema{
				Type:	  schema.TypeString,
				Required: true,
			},

			"display_text": &schema.Schema{
                                Type:     schema.TypeString,
                                Required: true,
                        },

                        "gateway": &schema.Schema{
                                Type:     schema.TypeString,
                                Required: true,
                        },

			"zone": &schema.Schema{
				Type:     schema.TypeString,
				Required: true,
			},

			"sid": &schema.Schema{
                                Type:     schema.TypeString,
                                Computed: true,
                        },

			"router_endpoint_one": &schema.Schema{
                                Type:     schema.TypeString,
                                Computed: true,
                        },

			"router_endpoint_two": &schema.Schema{
                                Type:     schema.TypeString,
                                Computed: true,
                        },

                        "vlan": &schema.Schema{
                                Type:     schema.TypeString,
                                Computed: true,
                        },

		},
	}
}

func resourceNetAPIPrivateDirectConnectCreate(d *schema.ResourceData, meta interface{}) error {
	cs := meta.(*netAPI.NetAPIClient)

	displaytext := d.Get("display_text").(string)


	p := cs.Network.NewListNetworksParams()
	p.SetSubtype("privatedirectconnect")
	r, err := cs.Network.ListNetworks(p)

	// Can't search directly for displaytext, so we must filter the list of all VPNs
	fr := make([]*netAPI.Network, 0, len(r.Networks))
	for _, val := range r.Networks {
		if val.Displaytext == displaytext {
			fr = append(fr, val)
		}
	}

	if err != nil {
		return fmt.Errorf("Error checking for existing private direct connect %s: %s", displaytext, err)
	}
	if len(fr) == 0 {
		// Create the private direct connect
		// TODO: reformat the zonename so that the (ESX) portion is removed if passed in
		zonename := d.Get("zone").(string)
		cidr := d.Get("cidr").(string)
		gateway := d.Get("gateway").(string)

		// Create a new parameter struct
		p2 := cs.PrivateDirectConnect.NewCreatePrivateDirectConnectParams(displaytext, zonename, cidr, gateway)
		p2.SetDcgname(d.Get("dcg").(string))

		// Create the new private direct connect
		r2, err := cs.PrivateDirectConnect.CreatePrivateDirectConnect(p2)
		if err != nil {
			return fmt.Errorf("Error creating private direct connect %s: %s", displaytext, err)
		}

		d.SetId(r2.ListPrivateDirectConnects[0].Id)
		d.Set("sid", r2.ListPrivateDirectConnects[0].Sid)
		d.Set("router_endpoint_one", r2.ListPrivateDirectConnects[0].Routerendpoint1)
		d.Set("router_endpoint_two", r2.ListPrivateDirectConnects[0].Routerendpoint2)
		d.Set("vlan", r2.ListPrivateDirectConnects[0].Vlan)
	} else if len(fr) == 1 {
		// Network already exists so we must adopt it
		d.SetId(fr[0].Id)

		// unfortunately we can now never get hold of the computed values
		d.Set("sid", "VALUE_UNAVAILABLE")
                d.Set("router_endpoint_one", "VALUE_UNAVAILABLE")
                d.Set("router_endpoint_two", "VALUE_UNAVAILABLE")
                d.Set("vlan", "VALUE_UNAVAILABLE")
	} else {
		return fmt.Errorf("You have multiple private direct connects with the same identifier (%s)", displaytext) 
	}
	return resourceNetAPIPrivateDirectConnectRead(d, meta)
}

func resourceNetAPIPrivateDirectConnectRead(d *schema.ResourceData, meta interface{}) error {
	cs := meta.(*netAPI.NetAPIClient)

        n, count, err := cs.Network.GetNetworkByID(d.Id())
        if err != nil {
                if count == 0 {
                        log.Printf(
                                "[DEBUG] Network %s does no longer exist", d.Get("name").(string))
                        d.SetId("")
                        return nil
                }

                return err
        }

        d.Set("display_text", n.Displaytext)
        d.Set("cidr", n.Cidr)
	d.Set("dcg", n.Dcgfriendlyname)
	d.Set("gateway", n.Gateway)

	return nil
}

func resourceNetAPIPrivateDirectConnectDelete(d *schema.ResourceData, meta interface{}) error {
	// Can't delete these resources so just stop managing them
	return nil
}

// TODO - could be userful ??
func parseCIDR(cidr string) (map[string]string, error) {
	m := make(map[string]string, 4)

	ip, ipnet, err := net.ParseCIDR(cidr)
	if err != nil {
		return nil, fmt.Errorf("Unable to parse cidr %s: %s", cidr, err)
	}

	msk := ipnet.Mask
	sub := ip.Mask(msk)

	m["netmask"] = fmt.Sprintf("%d.%d.%d.%d", msk[0], msk[1], msk[2], msk[3])
	m["gateway"] = fmt.Sprintf("%d.%d.%d.%d", sub[0], sub[1], sub[2], sub[3]+1)
	m["start"] = fmt.Sprintf("%d.%d.%d.%d", sub[0], sub[1], sub[2], sub[3]+2)
	m["end"] = fmt.Sprintf("%d.%d.%d.%d",
		sub[0]+(0xff-msk[0]), sub[1]+(0xff-msk[1]), sub[2]+(0xff-msk[2]), sub[3]+(0xff-msk[3]-1))

	return m, nil
}
